
#pragma kernel ParseMeshVertBuffer
#pragma kernel ProcessMeshTriangle

StructuredBuffer<uint> _TargetMeshRawVertexBuffer;
struct SpawnData
{
    float3 positionWS;
    float3 normalWS;
    float3 color;
    float2 uv;
};
RWStructuredBuffer<SpawnData> _SpawnBuffer;
float4x4 _LocalToWorld;

[numthreads(128,1,1)]
void ParseMeshVertBuffer(uint3 id : SV_DispatchThreadID)
{
    uint vertexStart = id.x * 12;
    
    float3 position = asfloat(uint3(
        _TargetMeshRawVertexBuffer[vertexStart],
        _TargetMeshRawVertexBuffer[vertexStart + 1],
        _TargetMeshRawVertexBuffer[vertexStart + 2]
    ));
    float3 normal = 
     asfloat(uint3(
        _TargetMeshRawVertexBuffer[vertexStart + 3],
        _TargetMeshRawVertexBuffer[vertexStart + 4],
        _TargetMeshRawVertexBuffer[vertexStart + 5]
    ));
    float4 tangent =
     asfloat(uint4(
        _TargetMeshRawVertexBuffer[vertexStart + 6],
        _TargetMeshRawVertexBuffer[vertexStart + 7],
        _TargetMeshRawVertexBuffer[vertexStart + 8],
        _TargetMeshRawVertexBuffer[vertexStart + 9]
    ));
    //float4 color =
    // asfloat(uint4(
    //    _TargetMeshRawVertexBuffer[vertexStart + 10],
    //    _TargetMeshRawVertexBuffer[vertexStart + 11],
    //    _TargetMeshRawVertexBuffer[vertexStart + 12],
    //    _TargetMeshRawVertexBuffer[vertexStart + 13]
    //));
    float2 uv0 =
     asfloat(uint2(
        _TargetMeshRawVertexBuffer[vertexStart + 10],
        _TargetMeshRawVertexBuffer[vertexStart + 11]
    ));
    SpawnData o;
    o.positionWS = mul(_LocalToWorld, float4(position, 1)).xyz;
    // o.positionOS = position;
    o.normalWS = mul(_LocalToWorld, float4(normal, 0)).xyz;
    o.color = 0;
    o.uv = uv0;
    _SpawnBuffer[id.x] = o;

}

struct UnitTriangle
{
    float3 p1;
    float3 p2;
    float3 p3;
};
StructuredBuffer<uint> _TargetMeshIndexBuffer;
float4x4 _Camera_V, _Camera_P;

void SpaceConversion(float3 pos, out float3 posVS, out float3 posNDS, out float2 uv)
{
    posVS = mul(_Camera_V, float4(pos, 1)).xyz;
    float4 posCS = mul(_Camera_P, float4(posVS, 1));
    posNDS = posCS.xyz / posCS.w;
    posNDS.z = posCS.w;
    uv = posNDS.xy * 0.5 + 0.5;
}
[numthreads(128, 1, 1)]
void ProcessMeshTriangle(uint3 id : SV_DispatchThreadID)
{


    UnitTriangle t;
    uint triStart = id.x * 3;
    t.p1 = _SpawnBuffer[_TargetMeshIndexBuffer[triStart]].positionWS;
    t.p2 = _SpawnBuffer[_TargetMeshIndexBuffer[triStart + 1]].positionWS;
    t.p3 = _SpawnBuffer[_TargetMeshIndexBuffer[triStart + 2]].positionWS;
    
    
    float3 pos = (t.p1 + t.p2 + t.p3) * 0.333333;

    float3 posNDS;
    float3 posVS;
    float2 uv;
   
    SpaceConversion(pos, posVS, posNDS, uv);
    
    float rate = 1.1;
    bool isInView =
    posNDS.x > -rate
    && posNDS.x < rate
    && posNDS.y > - rate
    && posNDS.y < rate
    && posNDS.z > -0.1
    ;

    _SpawnBuffer[_TargetMeshIndexBuffer[triStart]].color = isInView;
    _SpawnBuffer[_TargetMeshIndexBuffer[triStart + 1]].color = isInView;
    _SpawnBuffer[_TargetMeshIndexBuffer[triStart + 2]].color = isInView;
}
