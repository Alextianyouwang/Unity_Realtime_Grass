
#pragma kernel ParseMeshVertBuffer
#pragma kernel ProcessMeshTriangle
#include "../../../INCLUDE/HL_PrefixSum.hlsl"

StructuredBuffer<uint> _TargetMeshRawVertexBuffer;
struct SpawnData
{
    float3 positionWS;
    float3 normalWS;
    float3 color;
    float2 uv;
};
RWStructuredBuffer<SpawnData> _SpawnBuffer;
float4x4 _LocalToWorld;


[numthreads(128,1,1)]
void ParseMeshVertBuffer(uint3 id : SV_DispatchThreadID)
{
    uint vertexStart = id.x * 12;
    
    float3 position = asfloat(uint3(
        _TargetMeshRawVertexBuffer[vertexStart],
        _TargetMeshRawVertexBuffer[vertexStart + 1],
        _TargetMeshRawVertexBuffer[vertexStart + 2]
    ));
    float3 normal = 
     asfloat(uint3(
        _TargetMeshRawVertexBuffer[vertexStart + 3],
        _TargetMeshRawVertexBuffer[vertexStart + 4],
        _TargetMeshRawVertexBuffer[vertexStart + 5]
    ));
    float4 tangent =
     asfloat(uint4(
        _TargetMeshRawVertexBuffer[vertexStart + 6],
        _TargetMeshRawVertexBuffer[vertexStart + 7],
        _TargetMeshRawVertexBuffer[vertexStart + 8],
        _TargetMeshRawVertexBuffer[vertexStart + 9]
    ));
    //float4 color =
    // asfloat(uint4(
    //    _TargetMeshRawVertexBuffer[vertexStart + 10],
    //    _TargetMeshRawVertexBuffer[vertexStart + 11],
    //    _TargetMeshRawVertexBuffer[vertexStart + 12],
    //    _TargetMeshRawVertexBuffer[vertexStart + 13]
    //));
    float2 uv0 =
     asfloat(uint2(
        _TargetMeshRawVertexBuffer[vertexStart + 10],
        _TargetMeshRawVertexBuffer[vertexStart + 11]
    ));
    SpawnData o;
    o.positionWS = mul(_LocalToWorld, float4(position, 1)).xyz;
    // o.positionOS = position;
    o.normalWS = mul(_LocalToWorld, float4(normal, 0)).xyz;
    o.color = 0;
    o.uv = uv0;
    _SpawnBuffer[id.x] = o;

}

struct UnitTriangle
{
    float3 p1;
    float3 p2;
    float3 p3;
};
StructuredBuffer<uint> _TargetMeshIndexBuffer;
float4x4 _Camera_V, _Camera_P;

void SpaceConversion(float3 pos, out float3 posVS, out float3 posNDS, out float2 uv)
{
    posVS = mul(_Camera_V, float4(pos, 1)).xyz;
    float4 posCS = mul(_Camera_P, float4(posVS, 1));
    posNDS = posCS.xyz / posCS.w;
    posNDS.z = posCS.w;
    uv = posNDS.xy * 0.5 + 0.5;
}
[numthreads(128, 1, 1)]
void ProcessMeshTriangle(uint3 id : SV_DispatchThreadID)
{


    UnitTriangle t;
    uint triStart = id.x * 3;
    t.p1 = _SpawnBuffer[_TargetMeshIndexBuffer[triStart]].positionWS;
    t.p2 = _SpawnBuffer[_TargetMeshIndexBuffer[triStart + 1]].positionWS;
    t.p3 = _SpawnBuffer[_TargetMeshIndexBuffer[triStart + 2]].positionWS;

    float3 p1NDS, p2NDS, p3NDS;
    float3 tmpVS;
    float2 tmpUV;

    SpaceConversion(t.p1, tmpVS, p1NDS, tmpUV);
    SpaceConversion(t.p2, tmpVS, p2NDS, tmpUV);
    SpaceConversion(t.p3, tmpVS, p3NDS, tmpUV);

    float rate = 1.0;

    bool isInView =
        (
            p1NDS.x > -rate && p1NDS.x < rate &&
            p1NDS.y > -rate && p1NDS.y < rate &&
            p1NDS.z > 0
        ) ||
        (
            p2NDS.x > -rate && p2NDS.x < rate &&
            p2NDS.y > -rate && p2NDS.y < rate &&
            p2NDS.z > 0
        ) ||
        (
            p3NDS.x > -rate && p3NDS.x < rate &&
            p3NDS.y > -rate && p3NDS.y < rate &&
            p3NDS.z > 0
        );

    if (!isInView)
    {
        // Example: Mark for discard
        //_VoteBuffer[triStart] = true;
        //_VoteBuffer[triStart + 1] = true;
        //_VoteBuffer[triStart + 2] = true;
        //return;
    }
    
  // _VoteBuffer[triStart] = false;
  // _VoteBuffer[triStart + 1] = false;
  // _VoteBuffer[triStart + 2] = false;
   

        _SpawnBuffer[_TargetMeshIndexBuffer[triStart]].color = isInView;
    _SpawnBuffer[_TargetMeshIndexBuffer[triStart + 1]].color = isInView;
    _SpawnBuffer[_TargetMeshIndexBuffer[triStart + 2]].color = isInView;
}
